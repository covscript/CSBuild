#!/usr/bin/env cs

import csbuild

constant VERSION = "1.0"

constant echo = system.out.println
constant echon = system.out.print
constant File = system.file
constant Path = system.path
constant IOStream = iostream

constant CONFIG_FILE_NAME = "csbuild.config"
constant configFilePath = [](path) -> path + Path.separator + CONFIG_FILE_NAME
constant isPathValid = [](path) -> File.exists(configFilePath(path))

@begin
constant fatalPathInvalid = [](path) -> (
    echo("fatal error: " + path + " is not an extension source directory"),
    echo("note: did you forget to run `csbuild init' first?"))
@end

@begin
constant print = [](...msg) -> 
    msg.size() > 1 ? 
    (system.out.print(msg.front()), msg.pop_front(), echo(msg...)) :
    system.out.println(msg.front())
@end

@begin
constant TEMPLATE_CONFIG = 
"import csbuild\n" + 
"\n" + 
"function csbuild_main(config)\n" + 
"    config.name = \"<extension-name>\"\n" +
"    config.author = \"<extension-author>\"\n" +
"    config.version = \"<extension-version>\"\n" +
"    config.version_code = 1\n" +
"    @begin\n" +
"    config.target(\"<target-name>\", {\"main.cpp\"})\n" + 
"    @end\n" +
"end\n"
@end

@begin
constant TEMPLATE_CMAKE_HEAD = 
"##############################################\n" +
"##############################################\n" +
"## DO NOT EDIT csbuild auto generated file. ##\n" +
"##############################################\n" +
"##############################################\n" +
"cmake_minimum_required(VERSION 3.4)\n" +
"\n" +
"include_directories(include)\n" +
"\n" +
"if(DEFINED ENV{CS_DEV_PATH})\n" +
"    include_directories($ENV{CS_DEV_PATH}/include)\n" +
"    link_directories($ENV{CS_DEV_PATH}/lib)\n" +
"endif()\n" +
"\n" +
"if(DEFINED ENV{CS_DEV_OUTPUT})\n" +
"    set(LIBRARY_OUTPUT_PATH $ENV{CS_DEV_OUTPUT})\n" +
"    set(EXECUTABLE_OUTPUT_PATH $ENV{CS_DEV_OUTPUT})\n" +
"endif()\n" +
"\n" +
"# Compiler Options\n" +
"set(CMAKE_CXX_STANDARD 14)\n" +
"\n" +
"if (MSVC)\n" +
"    set(CMAKE_CXX_FLAGS \"/O2 /EHsc /utf-8 /w\")\n" +
"    set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON)\n" +
"elseif (CMAKE_COMPILER_IS_GNUCXX)\n" +
"    if (WIN32)\n" +
"        set(CMAKE_C_FLAGS \"--static -fPIC -s -O3\")\n" +
"        set(CMAKE_CXX_FLAGS \"--static -fPIC -s -O3\")\n" +
"    else ()\n" +
"        set(CMAKE_C_FLAGS \"-fPIC -s -O3\")\n" +
"        set(CMAKE_CXX_FLAGS \"-fPIC -s -O3\")\n" +
"    endif ()\n" +
"else ()\n" +
"    set(CMAKE_C_FLAGS \"-fPIC -O3\")\n" +
"    set(CMAKE_CXX_FLAGS \"-fPIC -O3\")\n" +
"endif ()\n" +
"\n\n\n" + 
"# Extension Configuration\n"
@end

function loadConfig(file)
    var config = new csbuild.config
    var ns = context.source_import(configFile)
    ns.csbuild_main(config)
    return config
end

function csbuild_help()
    @begin
    echo("CSBuild: The CovScript build system.\n" + 
        "Usage: csbuild <command> [args...]\n" + 
        "  where commands are:\n" + 
        "    init        Initialize CovScript Extension directory\n" + 
        "    check       Check build files but don't build any extension\n" + 
        "    generate    Generate build files accroding to csbuild.config\n" + 
        "    make        Build extension\n" + 
        "    run         Build and run extension in CovScript REPL\n" +
        "    push        Publish extension to public server\n" +
        "    help        Show this text\n" + 
        "    version     Display CSBuild version\n" +
        "\n" + 
        "for detailed help of a command, type `csbuild <command> help'\n");
    @end
    return 0
end

function csbuild_version()
    echo("csbuild v" + VERSION)
    return 0
end

function csbuild_init(args)
    var path = "."
    var force = false

    foreach it in args
        var arg = it
        args.pop_front()
        switch arg
            case "help"; echo("No help currently :)"); return 0; end
            case "-f"; force = true; end
            default; path = arg; end
        end
    end

    var configFile = configFilePath(path)

    if !force && File.exists(configFile)
        echo("fatal error: " + path + " has been initialized as extension source directory")
        echo("note: use -f option to force re-initialize, which leads to a clear start")
        return 1
    end

    var configFileStream = IOStream.fstream(configFile, IOStream.openmode.out)
    configFileStream.println(TEMPLATE_CONFIG);

    echo(":: Initialized " + path + " as extension source directory.")
    echo("   Start your project by editing csbuild.config!")
    return 0
end

function csbuild_check(args)
    var path = "."

    foreach it in args
        var arg = it
        args.pop_front()
        switch arg
            case "help"; echo("No help currently :)"); return 0; end
            default; path = arg; end
        end
    end

    if !isPathValid(path)
        fatalPathInvalid(path)
        return 1
    end

    var configFile = configFilePath(path)
    var cfg = loadConfig(configFile)

    echo("  > Extension Name:      " + cfg.name)
    echo("  > Extension Author:    " + cfg.author)
    echo("  > Extension Version:   " + cfg.version)
    echo("  > Extension Targets:   ")
    foreach item in cfg.targets
        var target = item.second()
        echo("    > " + target->name)
        echon("        source: ")
        foreach item in target->source
            echon(item + " ")
        end
        echo("")
        echon("        libs: ")
        foreach item in target->libs
            echon(item + " ")
        end
        echo("")
        echo("        compile options: " + target->options)
    end
    return 0
end

function csbuild_generate_target(stream, target)
    var libName = target->name
    var cmakeCode = "# Extension Target: " + libName + "\n"
    cmakeCode += "add_library(" + libName + " SHARED "
    foreach item in target->source
        cmakeCode += ".." + Path.separator + item + " ";
    end
    cmakeCode += ")\n"
    cmakeCode += "target_link_libraries(" + libName + " covscript)\n"
    cmakeCode += "target_link_libraries(" + libName + " "
    foreach item in target->libs
        cmakeCode += item + " ";
    end
    cmakeCode += ")\n"

    cmakeCode += "set_target_properties(" + libName + " PROPERTIES OUTPUT_NAME " + libName + ")\n"
    cmakeCode += "set_target_properties(" + libName + " PROPERTIES PREFIX \"\")\n"
    cmakeCode += "set_target_properties(" + libName + " PROPERTIES SUFFIX \".cse\")\n"
    cmakeCode += "# Extension Target End: " + libName + "\n"
    stream.println(cmakeCode)
end

function csbuild_generate(args)
    var path = "."

    foreach it in args
        var arg = it
        args.pop_front()
        switch arg
            case "help"; echo("No help currently :)"); return 0; end
            default; path = arg; end
        end
    end

    if !isPathValid(path)
        fatalPathInvalid(path)
        return 1
    end

    var configFile = configFilePath(path)
    var cfg = loadConfig(configFile)

    system.run("mkdir -p gen")
    var stream = IOStream.fstream("gen" + Path.separator + "CMakeLists.txt", IOStream.openmode.out)
    stream.println(TEMPLATE_CMAKE_HEAD)

    foreach item in cfg.targets
        var target = item.second()
        csbuild_generate_target(stream, target)
    end
    return 0
end

function csbuild_make(args)
    return 0
end

function csbuild_run(args)
    return 0
end

function csbuild_push(args)
    return 0
end

function main(args)
    args.pop_front()
    foreach it in args
        var arg = it
        args.pop_front()
        switch arg
            case "init"; return csbuild_init(args); end
            case "check"; return csbuild_check(args); end
            case "generate"; return csbuild_generate(args); end
            case "make"; return csbuild_make(args); end
            case "run"; return csbuild_run(args); end
            case "push"; return csbuild_push(args); end
            case "version"; return csbuild_version(); end
            case "help"; return csbuild_help(); end
            default
                echo("csbuild: Unrecognized command: " + arg)
                echo("Type 'csbuild help' for help")
                return 1
            end
        end
    end
    csbuild_help()
    return 1
end

system.exit(main(clone(context.cmd_args())))
